# JuFireX 关键代码片段集合

## 1. 前端核心代码片段

### 1.1 用户状态管理 (Pinia Store)

**文件**: `frontend/src/store/user.ts`

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { UserInfo, UserSession } from '@/types'
import { getUserSession, getUserInfo, login, logout, checkAuthStatus } from '@/api'

export const useUserStore = defineStore('user', () => {
  // 状态
  const userInfo = ref<UserInfo | null>(null)
  const isLoggedIn = ref<boolean>(false)
  const isLoading = ref<boolean>(false)

  // 计算属性
  const nickname = computed(() => userInfo.value?.nickname || '')
  const avatar = computed(() => userInfo.value?.avatar || null)
  const permission = computed(() => userInfo.value?.permission || 0)
  const username = computed(() => userInfo.value?.username || '')

  // 初始化用户状态
  async function initUserState() {
    isLoading.value = true
    try {
      const response = await checkAuthStatus()
      if (response.code === 200 && response.data) {
        isLoggedIn.value = response.data.isLoggedIn
        userInfo.value = response.data.user
      } else {
        clearUserState()
      }
    } catch (error) {
      console.error('检查用户状态失败:', error)
      clearUserState()
    } finally {
      isLoading.value = false
    }
  }

  // 用户登录
  async function userLogin(credentials: { username: string; password: string }) {
    isLoading.value = true
    try {
      const response = await login(credentials)
      if (response.code === 200 && response.data) {
        isLoggedIn.value = true
        userInfo.value = response.data
        return response.data
      } else {
        throw new Error(response.message || '登录失败')
      }
    } catch (error) {
      console.error('登录失败:', error)
      throw error
    } finally {
      isLoading.value = false
    }
  }

  // 用户登出
  async function userLogout() {
    isLoading.value = true
    try {
      const response = await logout()
      if (response.code === 200) {
        clearUserState()
      } else {
        throw new Error(response.message || '登出失败')
      }
    } catch (error) {
      console.error('登出失败:', error)
      clearUserState()
      throw error
    } finally {
      isLoading.value = false
    }
  }

  // 清除用户状态
  function clearUserState() {
    isLoggedIn.value = false
    userInfo.value = null
  }

  return {
    // 状态
    userInfo,
    isLoggedIn,
    isLoading,
    
    // 计算属性
    nickname,
    avatar,
    permission,
    username,
    
    // 方法
    initUserState,
    userLogin,
    userLogout,
    clearUserState
  }
})
```

### 1.2 HTTP请求封装

**文件**: `frontend/src/utils/request.ts`

```typescript
import axios from 'axios'

declare global {
  interface ImportMetaEnv {
    readonly VITE_API_BASE?: string
    readonly VITE_TIMEOUT?: string
  }

  interface ImportMeta {
    readonly env: ImportMetaEnv
  }
}

const http = axios.create({
  baseURL: import.meta.env.VITE_API_BASE,
  timeout: Number(import.meta.env.VITE_TIMEOUT || 5000),
})

// 响应拦截器
http.interceptors.response.use(
  (res) => res.data,
  (err) => Promise.reject(err)
)

export default http
```

### 1.3 API接口定义

**文件**: `frontend/src/api/user.ts`

```typescript
import http from "@/utils/request";
import type { UserSession, UserInfo, ApiResponse } from "@/types";

// 获取当前用户session信息
export async function getUserSession(): Promise<ApiResponse<UserSession>> {
  return await http.get("/user/session");
}

// 获取用户详细信息
export async function getUserInfo(): Promise<ApiResponse<UserInfo>> {
  return await http.get("/user/info");
}

// 用户登录
export async function login(credentials: {
  username: string;
  password: string;
}): Promise<ApiResponse<UserInfo>> {
  return await http.post("/auth/login", credentials);
}

// 用户登出
export async function logout(): Promise<ApiResponse<null>> {
  return await http.post("/auth/logout");
}

// 检查登录状态
export async function checkAuthStatus(): Promise<ApiResponse<UserSession>> {
  return await http.get("/auth/status");
}
```

### 1.4 TypeScript类型定义

**文件**: `frontend/src/types/index.d.ts`

```typescript
export type Maybe<T> = T | null | undefined

// 用户信息接口
export interface UserInfo {
  id: number
  username: string
  nickname: string
  email: string
  avatar: string | null
  permission: number
  createdAt: string
  updatedAt: string
}

// 用户session信息接口
export interface UserSession {
  isLoggedIn: boolean
  user: UserInfo | null
}

// API响应基础接口
export interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
}
```

### 1.5 Vue组件示例 - 登录表单

**文件**: `frontend/src/views/Login.vue`

```vue
<template>
  <n-card embedded title="登录" class="col-3 mx-auto my-auto">
    <!-- 登录表单 -->
    <n-form ref="formRef" :model="modelRef" :rules="rules">
      <n-form-item path="username" label="用户名">
        <n-input 
          v-model:value="modelRef.username" 
          placeholder="请输入用户名" 
          @keydown.enter.prevent 
        />
      </n-form-item>
      <n-form-item path="password" label="密码">
        <n-input 
          v-model:value="modelRef.password" 
          type="password" 
          placeholder="请输入密码" 
          @keydown.enter.prevent 
        />
      </n-form-item>
    </n-form>

    <!-- 底部链接 -->
    <template #footer>
      <p class="mb-0">
        还没有账号？
        <router-link to="/register" class="text-decoration-none">立即注册</router-link>
      </p>
    </template>

    <template #action>
      <n-button type="primary" block size="large" @click="handleLogin">
        <i class="fas fa-sign-in-alt me-2"></i>
        登录
      </n-button>
    </template>
  </n-card>
</template>

<script setup lang="ts">
import type { FormInst, FormRules } from 'naive-ui'
import { NButton, NCard, NForm, NFormItem, NInput } from 'naive-ui'
import { useMessage } from 'naive-ui'
import { ref } from 'vue'

interface ModelType {
  username: string | null
  password: string | null
}

const formRef = ref<FormInst | null>(null)
const message = useMessage()

const modelRef = ref<ModelType>({
  username: null,
  password: null
})

const rules: FormRules = {
  username: [
    {
      required: true,
      message: '至少输个用户名啊喂!'
    }
  ],
  password: [
    {
      required: true,
      message: '还需要密码'
    }
  ]
}

function handleLogin() {
  handleValidateButtonClick(new MouseEvent('click'))
  console.log("登录按钮被点击" + JSON.stringify(modelRef.value, null, 2));
}

function handleValidateButtonClick(e: MouseEvent) {
  e.preventDefault()
  formRef.value?.validate((errors) => {
    if (!errors) {
      message.success('验证成功')
    } else {
      console.log(errors)
      message.error('验证失败')
    }
  })
}
</script>
```

## 2. 后端核心代码片段

### 2.1 认证服务类

**文件**: `backend/app/service/auth_service.py`

```python
import hashlib
import secrets
from datetime import datetime, timedelta
from typing import Dict, Optional, Any
from app.exception.api_exception import ApiException
from app.service.user_service import user_service

class AuthService:
    """认证服务类"""
    
    def __init__(self):
        # 模拟会话存储
        self._mock_sessions = {}
        # 模拟密码存储
        self._mock_passwords = {
            'admin': self._hash_password('admin123'),
            'user001': self._hash_password('password123')
        }
        # 模拟用户ID计数器
        self._next_user_id = 3

    def _hash_password(self, password: str) -> str:
        """密码哈希处理"""
        return hashlib.sha256(password.encode()).hexdigest()
    
    def _generate_session_token(self) -> str:
        """生成会话令牌"""
        return secrets.token_urlsafe(32)
    
    def authenticate_user(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """用户身份验证"""
        if not username or not password:
            return None
        
        # 获取用户信息
        user = user_service.get_user_by_username(username)
        if not user:
            return None
        
        # 验证密码
        stored_password_hash = self._mock_passwords.get(username)
        if not stored_password_hash:
            return None
        
        if stored_password_hash != self._hash_password(password):
            return None
        
        # 检查用户状态
        if not user.get('is_active', False):
            return None
        
        return user

    def login_user(self, username: str, password: str) -> Dict[str, Any]:
        """用户登录"""
        if not username or not password:
            raise ApiException(400, "用户名和密码不能为空")
        
        # 身份验证
        user = self.authenticate_user(username, password)
        if not user:
            raise ApiException(401, "用户名或密码错误")
        
        # 生成会话令牌
        session_token = self._generate_session_token()
        
        # 创建会话信息
        session_info = {
            'token': session_token,
            'user_id': user['id'],
            'username': user['username'],
            'created_at': datetime.utcnow().isoformat(),
            'expires_at': (datetime.utcnow() + timedelta(days=7)).isoformat(),
            'is_active': True
        }
        
        # 存储会话
        self._mock_sessions[session_token] = session_info
        
        # 更新用户最后登录时间
        user['last_login_at'] = datetime.utcnow().isoformat()
        user_service._mock_users[user['id']] = user
        
        return {
            'token': session_token,
            'user': {
                'id': user['id'],
                'username': user['username'],
                'nickname': user['nickname'],
                'avatar': user['avatar'],
                'permission': user['permission']
            },
            'expires_at': session_info['expires_at']
        }

    def check_auth_status(self, session_token: str) -> Dict[str, Any]:
        """检查认证状态"""
        session = self.get_session_info(session_token)
        
        if not session:
            return {
                'isLoggedIn': False,
                'is_authenticated': False,
                'user': None,
                'session': None
            }
        
        user = user_service.get_user_by_id(session['user_id'])
        if not user:
            return {
                'isLoggedIn': False,
                'is_authenticated': False,
                'user': None,
                'session': None
            }
        
        return {
            'isLoggedIn': True,
            'is_authenticated': True,
            'user': {
                'id': user['id'],
                'username': user['username'],
                'nickname': user['nickname'],
                'avatar': user['avatar'],
                'permission': user['permission']
            },
            'session': {
                'token': session['token'],
                'created_at': session['created_at'],
                'expires_at': session['expires_at']
            }
        }

# 创建服务实例
auth_service = AuthService()
```

### 2.2 用户服务类

**文件**: `backend/app/service/user_service.py`

```python
import re
from datetime import datetime
from typing import Dict, List, Optional, Any
from app.exception.api_exception import ApiException

class UserService:
    """用户服务类"""
    
    def __init__(self):
        # 模拟用户数据存储
        self._mock_users = {
            1: {
                'id': 1,
                'username': 'admin',
                'nickname': 'Administrator',
                'email': 'admin@jufirex.com',
                'avatar': '/static/avatars/admin.jpg',
                'permission': 3,
                'is_active': True,
                'is_verified': True,
                'created_at': '2024-01-01T00:00:00',
                'updated_at': '2024-01-01T00:00:00',
                'last_login_at': '2024-01-15T10:30:00'
            },
            2: {
                'id': 2,
                'username': 'user001',
                'nickname': 'Aurore',
                'email': 'aurore@example.com',
                'avatar': '/static/avatars/aurore.jpg',
                'permission': 1,
                'is_active': True,
                'is_verified': True,
                'created_at': '2024-01-02T00:00:00',
                'updated_at': '2024-01-02T00:00:00',
                'last_login_at': '2024-01-15T09:15:00'
            }
        }

    def get_user_by_id(self, user_id: int) -> Optional[Dict[str, Any]]:
        """根据用户ID获取用户信息"""
        if not isinstance(user_id, int) or user_id <= 0:
            raise ApiException(400, "用户ID必须是正整数")
        
        user = self._mock_users.get(user_id)
        if not user:
            return None
            
        return user.copy()

    def get_user_by_username(self, username: str) -> Optional[Dict[str, Any]]:
        """根据用户名获取用户信息"""
        if not username or not isinstance(username, str):
            return None
            
        for user in self._mock_users.values():
            if user['username'] == username:
                return user.copy()
        return None

    def get_user_public_info(self, user_id: int) -> Optional[Dict[str, Any]]:
        """获取用户公开信息（不包含敏感数据）"""
        user = self.get_user_by_id(user_id)
        if not user:
            return None
            
        # 返回公开信息，排除敏感字段
        return {
            'id': user['id'],
            'username': user['username'],
            'nickname': user['nickname'],
            'avatar': user['avatar'],
            'permission': user['permission'],
            'created_at': user['created_at']
        }

    def validate_user_data(self, user_data: Dict[str, Any], is_update: bool = False) -> Dict[str, str]:
        """验证用户数据"""
        errors = {}
        
        # 验证用户名
        if 'username' in user_data:
            username = user_data.get('username', '').strip()
            if not username:
                errors['username'] = '用户名不能为空'
            elif len(username) < 3 or len(username) > 50:
                errors['username'] = '用户名长度必须在3-50个字符之间'
            elif not re.match(r'^[a-zA-Z0-9_]+$', username):
                errors['username'] = '用户名只能包含字母、数字和下划线'
            elif not is_update and self.get_user_by_username(username):
                errors['username'] = '用户名已存在'
        elif not is_update:
            errors['username'] = '用户名不能为空'
        
        # 验证邮箱
        if 'email' in user_data:
            email = user_data.get('email', '').strip()
            if not email:
                errors['email'] = '邮箱不能为空'
            elif not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
                errors['email'] = '邮箱格式不正确'
        
        return errors

# 创建服务实例
user_service = UserService()
```

### 2.3 API路由层

**文件**: `backend/app/api/auth.py`

```python
from flask import Blueprint, request, make_response
from app.service.auth_service import auth_service
from app.utils.responses import success, fail
from app.exception.api_exception import ApiException

# 创建认证路由蓝图
bp = Blueprint("auth", __name__, url_prefix="/api/auth")

def get_session_token():
    """从请求头中获取会话令牌"""
    # 从Authorization头获取Bearer token
    auth_header = request.headers.get('Authorization', '')
    if auth_header.startswith('Bearer '):
        return auth_header[7:]  # 移除 'Bearer ' 前缀
    
    # 从Cookie中获取token
    return request.cookies.get('session_token')

@bp.route("/login", methods=["POST"])
def login():
    """用户登录接口"""
    try:
        # 获取请求数据
        data = request.get_json()
        if not data:
            return fail(400, "请求数据不能为空")
        
        username = data.get('username', '').strip()
        password = data.get('password', '')
        
        if not username or not password:
            return fail(400, "用户名和密码不能为空")
        
        # 调用服务层进行用户登录
        login_result = auth_service.login_user(username, password)
        
        # 创建响应并设置Cookie
        response = make_response(success(login_result, "登录成功"))
        response.set_cookie(
            'session_token', 
            login_result['token'],
            max_age=7*24*60*60,  # 7天
            httponly=True,
            secure=False,  # 开发环境设为False，生产环境应设为True
            samesite='Lax'
        )
        
        return response
        
    except ApiException as e:
        return fail(e.code, e.message)
    except Exception as e:
        return fail(500, f"服务器内部错误: {str(e)}")

@bp.route("/status", methods=["GET"])
def check_status():
    """检查登录状态接口"""
    try:
        # 获取会话令牌
        session_token = get_session_token()
        
        # 检查认证状态
        auth_status = auth_service.check_auth_status(session_token)
        
        return success(auth_status, "获取认证状态成功")
        
    except ApiException as e:
        return fail(e.code, e.message)
    except Exception as e:
        return fail(500, f"服务器内部错误: {str(e)}")
```

### 2.4 响应工具类

**文件**: `backend/app/utils/responses.py`

```python
from flask import jsonify

def success(data=None, message: str = "ok"):
    """成功响应"""
    return jsonify({"code": 200, "message": message, "data": data or {}}), 200

def fail(code: int = 400, message: str = "error", data=None):
    """失败响应"""
    return jsonify({"code": code, "message": message, "data": data or {}}), code
```

### 2.5 异常处理类

**文件**: `backend/app/exception/api_exception.py`

```python
class ApiException(Exception):
    """API异常类"""
    def __init__(self, code: int, message: str):
        super().__init__(message)
        self.code = code
        self.message = message
```

### 2.6 数据模型类

**文件**: `backend/app/model/user.py`

```python
from datetime import datetime
from app.model import db

class User(db.Model):
    """用户模型类"""
    __tablename__ = "users"
    
    # 基础字段
    id = db.Column(db.Integer, primary_key=True, comment="用户ID")
    username = db.Column(db.String(50), unique=True, nullable=False, comment="用户名")
    nickname = db.Column(db.String(100), nullable=False, comment="用户昵称")
    email = db.Column(db.String(255), unique=True, nullable=False, comment="邮箱地址")
    password = db.Column(db.String(255), nullable=False, comment="密码哈希")
    
    # 用户信息字段
    avatar = db.Column(db.String(500), nullable=True, comment="头像路径")
    permission = db.Column(db.Integer, default=1, nullable=False, comment="权限等级")
    
    # 状态字段
    is_active = db.Column(db.Boolean, default=True, nullable=False, comment="是否激活")
    is_verified = db.Column(db.Boolean, default=False, nullable=False, comment="是否已验证邮箱")
    
    # 时间戳字段
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False, comment="创建时间")
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False, comment="更新时间")
    last_login_at = db.Column(db.DateTime, nullable=True, comment="最后登录时间")

    def __repr__(self) -> str:
        return f"<User {self.username}({self.email})>"
    
    def to_dict(self, include_sensitive=False):
        """将用户对象转换为字典格式"""
        user_dict = {
            'id': self.id,
            'username': self.username,
            'nickname': self.nickname,
            'email': self.email,
            'avatar': self.avatar,
            'permission': self.permission,
            'is_active': self.is_active,
            'is_verified': self.is_verified,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'last_login_at': self.last_login_at.isoformat() if self.last_login_at else None
        }
        
        if include_sensitive:
            user_dict['password'] = self.password
            
        return user_dict

    def to_public_dict(self):
        """获取用户公开信息（不包含敏感数据）"""
        return {
            'id': self.id,
            'username': self.username,
            'nickname': self.nickname,
            'avatar': self.avatar,
            'permission': self.permission,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
```

## 3. 配置文件示例

### 3.1 Vite配置

**文件**: `frontend/vite.config.ts`

```typescript
import { defineConfig } from "vite";
import path from "node:path";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"),
    },
  },
  server: {
    port: 5173,
    proxy: {
      "/api": {
        target: "http://localhost:5000",
        changeOrigin: true,
      },
    },
  },
});
```

### 3.2 TypeScript配置

**文件**: `frontend/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/": ["./src/"],
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
```

### 3.3 Flask配置

**文件**: `backend/config.py`

```python
import os

class BaseConfig:
    SQLALCHEMY_DATABASE_URI = os.getenv("DATABASE_URL", "sqlite:///app.db")
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-this-secret")
    DEBUG = False
    TESTING = False

class DevelopmentConfig(BaseConfig):
    DEBUG = True

class TestingConfig(BaseConfig):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = os.getenv("TEST_DATABASE_URL", "sqlite:///test.db")

class ProductionConfig(BaseConfig):
    DEBUG = False
```

### 3.4 环境变量配置

**文件**: `frontend/.env.development`

```env
VITE_API_BASE=/api
VITE_TIMEOUT=5000
```

**文件**: `frontend/.env.production`

```env
VITE_API_BASE=https://api.your-domain.com
VITE_TIMEOUT=10000
```

## 4. 最佳实践代码示例

### 4.1 错误处理最佳实践

```typescript
// 前端全局错误处理
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

// 全局错误处理
app.config.errorHandler = (err, vm, info) => {
  console.error('全局错误:', err)
  console.error('错误信息:', info)
  
  // 发送错误到监控服务
  // sendErrorToMonitoring(err, info)
}

// 全局未捕获的Promise错误
window.addEventListener('unhandledrejection', event => {
  console.error('未处理的Promise错误:', event.reason)
  event.preventDefault()
})
```

### 4.2 API请求重试机制

```typescript
// 带重试机制的HTTP请求
import axios, { AxiosRequestConfig } from 'axios'

interface RetryConfig extends AxiosRequestConfig {
  retryTimes?: number
  retryDelay?: number
}

async function requestWithRetry(config: RetryConfig): Promise<any> {
  const { retryTimes = 3, retryDelay = 1000, ...axiosConfig } = config
  
  for (let i = 0; i < retryTimes; i++) {
    try {
      const response = await axios(axiosConfig)
      return response.data
    } catch (error) {
      if (i === retryTimes - 1) {
        throw error
      }
      
      // 等待后重试
      await new Promise(resolve => setTimeout(resolve, retryDelay * (i + 1)))
    }
  }
}
```

### 4.3 防抖和节流工具函数

```typescript
// 防抖函数
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null
  
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null
      func(...args)
    }
    
    if (timeout) {
      clearTimeout(timeout)
    }
    timeout = setTimeout(later, wait)
  }
}

// 节流函数
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean = false
  
  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}
```

### 4.4 后端装饰器模式

```python
# 权限检查装饰器
from functools import wraps
from flask import request
from app.service.auth_service import auth_service
from app.utils.responses import fail

def require_auth(permission_level: int = 0):
    """权限检查装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # 获取会话令牌
            auth_header = request.headers.get('Authorization', '')
            if not auth_header.startswith('Bearer '):
                return fail(401, "未提供认证令牌")
            
            token = auth_header[7:]
            
            # 验证令牌
            auth_status = auth_service.check_auth_status(token)
            if not auth_status['is_authenticated']:
                return fail(401, "认证失败")
            
            # 检查权限
            user_permission = auth_status['user']['permission']
            if user_permission < permission_level:
                return fail(403, "权限不足")
            
            # 将用户信息添加到请求上下文
            request.current_user = auth_status['user']
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

# 使用示例
@bp.route("/admin/users", methods=["GET"])
@require_auth(permission_level=2)  # 需要管理员权限
def get_admin_users():
    """获取用户列表（管理员功能）"""
    # 业务逻辑
    pass
```

这些代码片段展示了JuFireX项目中的核心实现模式和最佳实践，可以作为开发参考和代码复用的基础。